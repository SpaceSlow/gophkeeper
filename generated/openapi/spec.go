// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xZ0W/bthP+Vwj+fsBeFMtpsof5aV2bDtmGtWjadUAaFIx0tthJJHs8OTEC/e8DScm2",
	"LMlO09pt0T1ZoMS74933fTzSdzzRhdEKFFk+ueM2yaAQ/vEJgiC4AGUlyTm8hERj+hI+lGDJvTeoDSBJ",
	"8F8XQCIVJNwz3IrC5MAn3OoCmFRTjYUgqRUT17okZhujDL1VHnFaGD+BUKoZr5qBO/5/hCmf8P/Fq0Dj",
	"Osp4I7hXCwNnqix4VUUc4UMpEVI+uQy2olWMV0t/+vo9JOT8DSzXGq0sdNcr09ZKj8dLk1IRzACdza86",
	"KXLpYUdmzhA1DmcC3Gv/lIJNUBq3Jj6px1lRWmLW5JLY9YK9fYvMLoprnXeXtxFfbbcvoj+kpXtXapnX",
	"dyGvoXwEhf3ITK4KwAWiWHQi7nrqDV7PpHptAQe5ZIS1N85hCzbN6HEfMEoLqEQB7SnN6PHOZC/nRyvv",
	"O4Ifyjfpf0D5h60ew2d9Pl7CTFoC/Nw5QjCO4um7ryS/fRH15WMTht+zFg0ZdIvyv5fciEUBio4SEeKG",
	"W+IRv5ZK4IJHPEFIQZEU+ZqDtapZSEqUtLhwSwj5FSVl7vcaBAI+87niE/7bm1c8CjumsxHerjKVERle",
	"OZMuv25+ohWJxIMZCiFzV6CZxpGcC6XnI0k/u9ERlm6luUyg5lcAHn+mkUFaJr5QvgKSfBEvbsRsBsh+",
	"1Sb7HcAAsiP23IB6/OKcnYzGPOJzQBtk+Xg0Ho3dbG1ACSP5hJ+MxqMTj0zK/ILj3NHcA00H8rWl3asA",
	"c5hmUjHKYN31XArWwJ0JlbI1wDvU+vDPUz7hL7Qlb4oHNIClX3S6aFIFyrsWxuQyLDp+b7VatSm70NdR",
	"2qqNO8IS/ECQMr/0R+PxPvzXYukDaOfyokwSsHZa5myZHR7xDEQKYVv9++js1kgEe/R4SoDdcqSCHInZ",
	"61dP2E0GinltZRBmNRj14U4b8Lo5RyS9Im2SwAV5+hnz0G4genJwruYil+kSNnEDGWZL5xX83ns6Pj5k",
	"SIlGhISW8GUaV7hONVj1AzG4ldYL048hX5tGyH2fM9/LMK2YBZw7PXZCUxaFk6R1OrliiJltdgzLr9yX",
	"MdY74jAjmz3z85CysbYnXvZt8Pen5iB9miw1aPkCAJbKlBS8/3Q472cOhLCiz6fisQWmAUj2dtUz6IUm",
	"lagsE8x3zUxPO+2FdYNJiQiKGqdtVPZ0/JbvU7q3nDDuK+KHlqw/NXOdimtugoOwDzwQDXUbxCeXTQN0",
	"eVVdtWESCtup5hpkuu+uqmhAw17kIgEmmIKbjs2upPUK12arvB/92nozUtVK1gLm8b59PwSaX1Yfvw5i",
	"nD56dLg4/nI5CAHAbQKmKcVe2BmAMkCnHQztFfj4TqZViDMHgm7ET/04E3nO3PmtT+jZjaSMeUOb9A2z",
	"N4D9RlJ2/tQfTVAUQL4jvrzj7nDijys8ak5HsmH7qoFYb3w3D8QuWRskPd3aXXw/ul7XcWvtHoaeuLmA",
	"2NIoPAQ7z4CS7EtCZ5uU6oSAjiwhiKKNiuVhbHk50TmJfWuNxun45KBxoJxlZBlp3x10ZM5HdHrQiPph",
	"2zS3Mt17O+b5M9X4cAIPNWivTa5FygJah3laF+PjWrWnThn2Rtb79ICfxNOBlu+/Vuzblo4DHuIf5wgi",
	"XYQbpR2b4AHU5H5c39UJeF/ObaBziXl9MW4ncZzrROSZthQLI7lzX9vaXMvzhiy2/nuiviKoFSFcS1TR",
	"lmk+a33n1NpE91V1Vf0bAAD//wVVeW4cHwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
